<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AutoPR â€” Job States (Swimlanes)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5rem 1rem 2rem;
      min-height: 100vh;
    }

    h1 {
      font-size: 1.35rem;
      font-weight: 650;
      letter-spacing: -0.02em;
      text-align: center;
    }

    .subtitle {
      color: #8b949e;
      margin: 0.35rem 0;
      font-size: 0.83rem;
      text-align: center;
    }

    /* â”€â”€ Legend â”€â”€ */
    .legend {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      border: 1.5px solid transparent;
      font-size: 0.82rem;
      font-weight: 500;
      user-select: none;
    }

    .legend-item:hover, .legend-item.active {
      border-color: currentColor;
      background: rgba(255,255,255,0.04);
    }

    .legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
    }

    .legend-item[data-actor="daemon"]  { color: #58a6ff; }
    .legend-item[data-actor="user"]    { color: #3fb950; }
    .legend-item[data-actor="llm"]     { color: #d29922; }
    .legend-item[data-actor="config"]  { color: #8b949e; }

    .legend-item[data-actor="daemon"]  .legend-dot { background: #58a6ff; }
    .legend-item[data-actor="user"]    .legend-dot { background: #3fb950; }
    .legend-item[data-actor="llm"]     .legend-dot { background: #d29922; }
    .legend-item[data-actor="config"]  .legend-dot { background: #8b949e; }

    .diagram-shell {
      width: min(95vw, 1500px);
    }

    .phase-ruler {
      display: grid;
      grid-template-columns: repeat(6, minmax(120px, 1fr));
      gap: 0.35rem;
      margin-bottom: 0.6rem;
      color: #6e7681;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      text-align: center;
    }

    .phase-ruler span {
      border: 1px solid #30363d;
      border-radius: 6px;
      background: #111720;
      padding: 0.45rem 0.35rem;
    }

    .viewport-tools {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 0.45rem;
      margin-bottom: 0.6rem;
    }

    .viewport-tools button {
      background: #21262d;
      border: 1px solid #30363d;
      color: #c9d1d9;
      border-radius: 6px;
      font-size: 0.78rem;
      font-weight: 600;
      padding: 0.28rem 0.52rem;
      cursor: pointer;
      min-width: 2rem;
    }

    .viewport-tools button:hover {
      border-color: #58a6ff;
      color: #f0f6fc;
    }

    .viewport-tools button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #30363d;
      color: #8b949e;
    }

    .zoom-level {
      min-width: 3.3rem;
      text-align: center;
      color: #8b949e;
      font-size: 0.74rem;
      font-variant-numeric: tabular-nums;
    }

    /* â”€â”€ Diagram wrapper â”€â”€ */
    #diagram-container {
      background: linear-gradient(180deg, rgba(22,27,34,0.92), rgba(15,20,27,0.92));
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 1.6rem;
      width: 100%;
      overflow-x: auto;
      position: relative;
      touch-action: none;
    }

    #diagram-container.panning {
      cursor: grabbing;
    }

    #diagram-container::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        linear-gradient(to right, rgba(110,118,129,0.17) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(110,118,129,0.12) 1px, transparent 1px);
      background-size:
        calc(100% / 6) 100%,
        100% calc(100% / 6);
      border-radius: 12px;
    }

    #diagram-container svg {
      width: 100% !important;
      height: auto !important;
      min-height: 62vh;
      position: relative;
      z-index: 1;
    }

    /* â”€â”€ Tooltip â”€â”€ */
    #tooltip {
      position: fixed;
      background: #1c2128;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 0.55rem 0.75rem;
      font-size: 0.78rem;
      max-width: 260px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.12s;
      z-index: 100;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      line-height: 1.45;
    }

    #tooltip.visible { opacity: 1; }

    #tooltip .tt-state {
      font-weight: 600;
      margin-bottom: 0.25rem;
      color: #e6edf3;
    }

    #tooltip .tt-desc { color: #8b949e; }

    /* â”€â”€ Mermaid color overrides (applied via JS post-render) â”€â”€ */

    /* During filtering: dim everything, then un-dim matches */
    #diagram-container.filtering svg .edge-path,
    #diagram-container.filtering svg g.edgeLabel {
      opacity: 0.06;
      transition: opacity 0.2s;
    }

    #diagram-container.filtering svg .edge-path.hl,
    #diagram-container.filtering svg g.edgeLabel.hl {
      opacity: 1;
    }

    /* Also dim nodes during legend filtering */
    #diagram-container.filtering svg .node,
    #diagram-container.filtering svg .cluster {
      opacity: 0.10;
      transition: opacity 0.2s;
    }

    #diagram-container.filtering svg .node.hl,
    #diagram-container.filtering svg .cluster.hl {
      opacity: 1;
    }

    /* Node filtering (click a node) */
    #diagram-container.node-filter svg .edge-path,
    #diagram-container.node-filter svg g.edgeLabel {
      opacity: 0.06;
      transition: opacity 0.2s;
    }

    #diagram-container.node-filter svg .edge-path.hl,
    #diagram-container.node-filter svg g.edgeLabel.hl {
      opacity: 1;
    }

    #diagram-container.node-filter svg .node {
      opacity: 0.15;
      transition: opacity 0.2s;
    }

    #diagram-container.node-filter svg .node.hl {
      opacity: 1;
    }

    #diagram-container.node-filter svg .cluster {
      opacity: 0.10;
      transition: opacity 0.2s;
    }

    #diagram-container.node-filter svg .cluster.hl {
      opacity: 1;
    }

    /* Cursors */
    svg .node { cursor: pointer; }
    svg .node.human-command-node { filter: drop-shadow(0 0 0.2rem rgba(63,185,80,0.25)); }
    svg g.edgeLabel { cursor: pointer; }
    svg .edge-path { cursor: pointer; pointer-events: stroke; stroke-width: 8; }
    svg .edge-path.edge-reentry { stroke-dasharray: 8 6; }

    /* â”€â”€ Instructions bar â”€â”€ */
    .instructions {
      margin-top: 1rem;
      display: flex;
      gap: 1.5rem;
      font-size: 0.75rem;
      color: #484f58;
      flex-wrap: wrap;
      justify-content: center;
    }

    .instructions kbd {
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 3px;
      padding: 0.1rem 0.35rem;
      font-family: inherit;
      font-size: 0.7rem;
    }

  </style>
</head>
<body>

  <h1>AutoPR &mdash; Job State Machine (Swimlane View)</h1>
  <p class="subtitle">Left-to-right timeline with row lanes: core flow, conflict recovery, shared actions, terminal states.</p>
  <p class="subtitle">Hover actor legend to filter &middot; Click action hubs (ap retry/ap cancel/step error) to group transitions &middot; Click a specific arrow to isolate one transition</p>

  <div class="legend">
    <div class="legend-item" data-actor="daemon">
      <span class="legend-dot"></span><span>Daemon &nbsp;(automatic)</span>
    </div>
    <div class="legend-item" data-actor="user">
      <span class="legend-dot"></span><span>User &nbsp;(CLI action)</span>
    </div>
    <div class="legend-item" data-actor="llm">
      <span class="legend-dot"></span><span>LLM &nbsp;(AI decision)</span>
    </div>
    <div class="legend-item" data-actor="config">
      <span class="legend-dot"></span><span>Config &nbsp;(auto_pr)</span>
    </div>
  </div>
  <div class="diagram-shell">
    <div class="phase-ruler" aria-hidden="true">
      <span>1 Intake</span>
      <span>2 Build</span>
      <span>3 Review + Test</span>
      <span>4 Rebase/Recover</span>
      <span>5 Approval Gate</span>
      <span>6 Terminal</span>
    </div>
    <div class="viewport-tools">
      <button id="zoom-out" type="button" aria-label="Zoom out">-</button>
      <button id="zoom-in" type="button" aria-label="Zoom in">+</button>
      <button id="zoom-reset" type="button" aria-label="Reset zoom">Reset</button>
      <span id="zoom-level" class="zoom-level">100%</span>
    </div>
    <div id="diagram-container">
      <pre class="mermaid">
flowchart LR
    start(( )) -->|"âš™ job created"| queued

    subgraph Lane_Core["Lane A Â· Core Pipeline"]
        direction LR
        queued([queued])
        planning([planning])
        implementing([implementing])
        reviewing([reviewing])
        testing([testing])
        rebasing([rebasing])
        ready([ready])
    end

    subgraph Lane_Conflicts["Lane B Â· Conflict Recovery"]
        direction LR
        resolving_conflicts([resolving_conflicts])
    end

    subgraph Lane_Actions["Lane C Â· Shared Actions"]
        direction LR
        ap_cancel([ðŸ‘¤ ap cancel])
        step_error([step error])
        ap_retry([ðŸ‘¤ ap retry])
    end

    subgraph Lane_Terminal["Lane D Â· Terminal States"]
        direction LR
        approved([approved])
        rejected([rejected])
        failed([failed])
        cancelled([cancelled])
    end

    queued   -->|"âš™ workspace ready / start plan"| planning
    planning -->|"âš™ write patch plan"| implementing
    implementing -->|"âš™ stage & finalize patch"| reviewing
    reviewing -->|"ðŸ¤– changes requested"| implementing
    reviewing -->|"ðŸ¤– approved"| testing
    testing -->|"âš™ CI failed â€” send feedback"| implementing
    testing -->|"âš™ CI green, sync branch"| rebasing
    rebasing -->|"âš™ git rebase (clean/no-op) + verify"| ready
    rebasing -->|"âš™ rebase conflict + diff3 parse"| resolving_conflicts
    rebasing -->|"âš™ rebase failed / conflict threshold reached"| failed

    resolving_conflicts -->|"ðŸ¤– resolve conflicts, git add, rebase --continue, tests pass"| ready
    resolving_conflicts -->|"ðŸ¤– conflict resolution failed"| failed
    resolving_conflicts -->|"âš™ tests failed after rebase recovery"| failed

    queued --> ap_cancel
    planning --> ap_cancel
    implementing --> ap_cancel
    reviewing --> ap_cancel
    testing --> ap_cancel
    rebasing --> ap_cancel
    resolving_conflicts --> ap_cancel
    ap_cancel --> cancelled

    planning --> step_error
    implementing --> step_error
    reviewing --> step_error
    testing --> step_error
    step_error --> failed

    ready -->|"ðŸ‘¤ ap approve (clean rebase + push; conflicts block)"| approved
    ready -->|"ðŸ“‹ auto_pr (clean rebase + push; conflicts block)"| approved
    ready -->|"ðŸ‘¤ ap reject"| rejected

    failed --> ap_retry
    rejected --> ap_retry
    cancelled --> ap_retry
    ap_retry --> queued
      </pre>
    </div>
  </div>

  <div class="instructions">
    <span>Wheel to zoom</span>
    <span>Drag empty area to pan</span>
    <span>Hover legend to filter</span>
    <span>Click action block to group</span>
    <span>Click state to isolate</span>
    <span>Click arrow to isolate one</span>
    <span>Click background to reset</span>
  </div>
  <div id="tooltip">
    <div class="tt-state"></div>
    <div class="tt-desc"></div>
  </div>

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      flowchart: {
        curve: 'linear',
        padding: 24,
        nodeSpacing: 58,
        rankSpacing: 120,
        useMaxWidth: false,
      },
      themeVariables: {
        primaryColor:       '#21262d',
        primaryTextColor:   '#c9d1d9',
        primaryBorderColor: '#30363d',
        lineColor:          '#484f58',
        secondaryColor:     '#161b22',
        tertiaryColor:      '#0d1117',
        clusterBkg:         'rgba(33,38,45,0.5)',
        clusterBorder:      '#30363d',
      }
    });

    await mermaid.run();

    // â”€â”€ Post-process: reposition cluster labels to top-left â”€â”€
    const svgEl = document.querySelector('#diagram-container svg');
    const LANE_STYLES = {
      'LANE A Â· CORE PIPELINE': {
        fill: 'rgba(22, 72, 106, 0.20)',
        stroke: '#2f81f7',
        label: '#79c0ff',
      },
      'LANE B Â· CONFLICT RECOVERY': {
        fill: 'rgba(110, 73, 15, 0.22)',
        stroke: '#d29922',
        label: '#e3b341',
      },
      'LANE C Â· SHARED ACTIONS': {
        fill: 'rgba(19, 86, 44, 0.22)',
        stroke: '#3fb950',
        label: '#56d364',
      },
      'LANE D Â· TERMINAL STATES': {
        fill: 'rgba(82, 24, 55, 0.20)',
        stroke: '#db61a2',
        label: '#f778ba',
      }
    };

    svgEl.querySelectorAll('.cluster').forEach(cluster => {
      const rect = cluster.querySelector('rect');
      if (!rect) return;

      // Extract the label text from whatever structure mermaid used
      const label = cluster.querySelector('.cluster-label');
      if (!label) return;
      const labelText = label.textContent.trim();
      if (!labelText) return;

      // Hide the original label entirely
      label.style.display = 'none';

      // Create a new SVG text element at top-left of the cluster rect
      const bbox = rect.getBBox();
      const newLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      newLabel.textContent = labelText.toUpperCase();
      newLabel.setAttribute('x', bbox.x + 10);
      newLabel.setAttribute('y', bbox.y + 16);
      newLabel.setAttribute('text-anchor', 'start');
      newLabel.setAttribute('dominant-baseline', 'auto');
      newLabel.style.fontSize = '11px';
      newLabel.style.fontWeight = '700';
      newLabel.style.fill = '#6e7681';
      newLabel.style.letterSpacing = '0.08em';
      newLabel.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif';
      newLabel.classList.add('cluster-label-custom');

      const laneStyle = LANE_STYLES[labelText.toUpperCase()];
      if (laneStyle) {
        rect.style.fill = laneStyle.fill;
        rect.style.stroke = laneStyle.stroke;
        rect.style.strokeWidth = '1.4px';
        newLabel.style.fill = laneStyle.label;
      }

      cluster.appendChild(newLabel);
    });

    // â”€â”€ Emoji-to-actor mapping â”€â”€
    const ACTOR_MAP = {
      'âš™': 'daemon',
      'ðŸ‘¤': 'user',
      'ðŸ¤–': 'llm',
      'ðŸ“‹': 'config',
    };

    const ACTOR_COLORS = {
      daemon: '#58a6ff',
      user:   '#3fb950',
      llm:    '#d29922',
      config: '#8b949e',
    };

    // â”€â”€ Node descriptions for tooltips â”€â”€
    const NODE_DESC = {
      queued:       'Job claimed by a worker and branch context is prepared.',
      planning:     'Create a concrete patch plan before edit and commit-like change set.',
      implementing: 'Draft change set in the feature branch state (local working tree updates).',
      reviewing:    'Self-review pass on the patch; can request edits or proceed.',
      testing:      'Run CI gate on the branch. Green â†’ readiness checks, red â†’ back to patching.',
      rebasing:     'Applies current branch onto the latest base branch. Clean or no-op rebases move to ready. Conflicts move to auto-resolution.',
      resolving_conflicts: 'LLM-assisted conflict resolution while rebasing. Resolves conflicts, stages files, continues rebase, and returns to ready on passing tests.',
      ready:        'All checks passed. At approval time, the branch is rebased onto the latest base branch. If the rebase is clean, the branch is pushed and a PR is created. If there are conflicts, the approve fails and the job stays in ready â€” use ap retry to re-run the full pipeline.',
      approved:     'PR branch is pushed and ready for merge.',
      rejected:     'Human rejected the job. Retryable via ap retry.',
      failed:       'A pipeline step errored. Retryable via ap retry.',
      cancelled:    'Cancelled by user. Retryable via ap retry.',
      ap_cancel:    'Cancel action hub. Incoming from active states; outgoing to cancelled.',
      step_error:   'System step error hub. Incoming from active states; outgoing to failed.',
      ap_retry:     'Retry action hub. Incoming from failed/rejected/cancelled; outgoing to queued.',
    };

    // â”€â”€ Viewport controls (vector zoom/pan via SVG viewBox) â”€â”€
    const container = document.getElementById('diagram-container');
    const svg = container.querySelector('svg');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomResetBtn = document.getElementById('zoom-reset');
    const zoomLevel = document.getElementById('zoom-level');

    const parseViewBox = (el) => {
      const vb = (el.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
      if (vb.length === 4 && vb.every(Number.isFinite)) {
        return { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
      }
      const box = el.getBBox();
      return { x: box.x, y: box.y, width: box.width, height: box.height };
    };

    const baseView = parseViewBox(svg);
    const view = { ...baseView };
    const MIN_ZOOM = 1;
    const MAX_ZOOM = 5;
    let isPanning = false;
    let panPointerId = null;
    let panStart = null;
    let suppressBackgroundClick = false;

    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const getZoom = () => baseView.width / view.width;

    const clampView = () => {
      const maxX = baseView.x + baseView.width - view.width;
      const maxY = baseView.y + baseView.height - view.height;
      view.x = clamp(view.x, baseView.x, maxX);
      view.y = clamp(view.y, baseView.y, maxY);
    };

    const applyView = () => {
      svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.width} ${view.height}`);
      const zoomPct = Math.round(getZoom() * 100);
      zoomLevel.textContent = `${zoomPct}%`;
      const atBase = getZoom() <= (MIN_ZOOM + 1e-4);
      zoomOutBtn.disabled = atBase;
      zoomResetBtn.disabled = atBase;
      zoomInBtn.disabled = getZoom() >= (MAX_ZOOM - 1e-4);
    };

    const zoomTo = (targetZoom, clientX, clientY) => {
      const nextZoom = clamp(targetZoom, MIN_ZOOM, MAX_ZOOM);
      const rect = svg.getBoundingClientRect();
      if (!rect.width || !rect.height) return;
      const px = clamp((clientX - rect.left) / rect.width, 0, 1);
      const py = clamp((clientY - rect.top) / rect.height, 0, 1);
      const anchorX = view.x + view.width * px;
      const anchorY = view.y + view.height * py;

      const nextWidth = baseView.width / nextZoom;
      const nextHeight = baseView.height / nextZoom;
      view.width = nextWidth;
      view.height = nextHeight;
      view.x = anchorX - nextWidth * px;
      view.y = anchorY - nextHeight * py;
      clampView();
      applyView();
    };

    const zoomBy = (factor, clientX, clientY) => {
      zoomTo(getZoom() * factor, clientX, clientY);
    };

    const resetZoom = () => {
      view.x = baseView.x;
      view.y = baseView.y;
      view.width = baseView.width;
      view.height = baseView.height;
      applyView();
    };

    const containerCenter = () => {
      const r = svg.getBoundingClientRect();
      return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
    };

    zoomInBtn.addEventListener('click', () => {
      const c = containerCenter();
      zoomBy(1.2, c.x, c.y);
    });
    zoomOutBtn.addEventListener('click', () => {
      const c = containerCenter();
      zoomBy(1 / 1.2, c.x, c.y);
    });
    zoomResetBtn.addEventListener('click', resetZoom);

    container.addEventListener('wheel', (e) => {
      if (Math.abs(e.deltaY) < 0.2) return;
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
      zoomBy(factor, e.clientX, e.clientY);
    }, { passive: false });

    const isInteractiveTarget = (target) => !!target.closest('.node, g.edgeLabel, .edge-path');
    svg.addEventListener('pointerdown', (e) => {
      if (e.button !== 0) return;
      if (getZoom() <= (MIN_ZOOM + 1e-4)) return;
      if (isInteractiveTarget(e.target)) return;
      isPanning = true;
      panPointerId = e.pointerId;
      panStart = { clientX: e.clientX, clientY: e.clientY, x: view.x, y: view.y, moved: false };
      try { svg.setPointerCapture(e.pointerId); } catch (_) {}
      container.classList.add('panning');
      e.preventDefault();
    });

    const endPan = (e) => {
      if (!isPanning || e.pointerId !== panPointerId) return;
      isPanning = false;
      panPointerId = null;
      container.classList.remove('panning');
      if (panStart?.moved) suppressBackgroundClick = true;
      panStart = null;
      try {
        if (svg.hasPointerCapture(e.pointerId)) svg.releasePointerCapture(e.pointerId);
      } catch (_) {}
    };

    svg.addEventListener('pointermove', (e) => {
      if (!isPanning || e.pointerId !== panPointerId || !panStart) return;
      const rect = svg.getBoundingClientRect();
      if (!rect.width || !rect.height) return;
      const dxPx = e.clientX - panStart.clientX;
      const dyPx = e.clientY - panStart.clientY;
      const unitsPerPxX = view.width / rect.width;
      const unitsPerPxY = view.height / rect.height;
      view.x = panStart.x - dxPx * unitsPerPxX;
      view.y = panStart.y - dyPx * unitsPerPxY;
      clampView();
      applyView();
      if (Math.abs(dxPx) + Math.abs(dyPx) > 4) panStart.moved = true;
    });
    svg.addEventListener('pointerup', endPan);
    svg.addEventListener('pointercancel', endPan);
    resetZoom();

    // â”€â”€ Post-process: classify edges by actor â”€â”€

    // Collect top-level edge labels and paths (Mermaid also emits nested span.edgeLabel)
    const edgeLabels = Array.from(svg.querySelectorAll('g.edgeLabel'));
    const edgePaths  = Array.from(svg.querySelectorAll('.edge-pattern-solid, .flowchart-link'));

    const edgePathById = new Map();
    edgePaths.forEach(path => {
      path.classList.add('edge-path');
      const edgeId = path.getAttribute('data-id') || path.id || null;
      if (edgeId) edgePathById.set(edgeId, path);
    });

    const STATE_IDS = new Set(['start', ...Object.keys(NODE_DESC)]);
    const parseEdgeId = (edgeId) => {
      if (!edgeId || !edgeId.startsWith('L_')) return null;
      const withPair = edgeId.slice(2);
      const lastUnderscore = withPair.lastIndexOf('_');
      if (lastUnderscore < 1) return null;
      const pair = withPair.slice(0, lastUnderscore);
      for (const source of STATE_IDS) {
        const prefix = source + '_';
        if (!pair.startsWith(prefix)) continue;
        const target = pair.slice(prefix.length);
        if (STATE_IDS.has(target)) return { source, target };
      }
      return null;
    };
    const actorFromLabel = (text = '') => {
      for (const [emoji, actor] of Object.entries(ACTOR_MAP)) {
        if (text.includes(emoji)) return actor;
      }
      return null;
    };
    const isReentryEdge = (edge) => {
      const byLabel = /ap retry|changes requested|tests failed/i.test(edge.labelText || '');
      const byRoute = edge.source === 'ap_retry' || edge.target === 'ap_retry' ||
                      (edge.source === 'reviewing' && edge.target === 'implementing') ||
                      (edge.source === 'testing' && edge.target === 'implementing');
      return byLabel || byRoute;
    };

    const edgeLabelById = new Map();
    edgeLabels.forEach(label => {
      const edgeId =
        label.querySelector('.label')?.getAttribute('data-id') ||
        label.getAttribute('data-id') ||
        null;
      if (edgeId && !edgeLabelById.has(edgeId)) edgeLabelById.set(edgeId, label);
    });

    // Build edge info from all path IDs (including unlabeled edges)
    const edges = [];
    const allEdgeIds = new Set([...edgePathById.keys(), ...edgeLabelById.keys()]);
    allEdgeIds.forEach(edgeId => {
      const label = edgeLabelById.get(edgeId) || null;
      const path = edgePathById.get(edgeId) || null;
      const text = label?.textContent || '';
      const labelText = text.replace(/\s+/g, ' ').trim();
      const parsed = parseEdgeId(edgeId);
      if (!parsed) return;
      edges.push({
        label,
        path,
        edgeId,
        source: parsed.source,
        target: parsed.target,
        text,
        labelText,
        actorHint: actorFromLabel(text),
      });
    });

    // â”€â”€ Extract edge connectivity from mermaid's internal data â”€â”€
    // Mermaid flowchart edges have IDs like L_source_target_0.
    const edgeConnections = []; // { source, target, actor, desc, labelEl, pathEl, edgeId }

    // Parse from the known diagram structure (we know the exact edges)
    const EDGE_DEFS = [
      { source: 'start',        target: 'queued',       actor: 'daemon',  desc: 'A new issue is picked up from GitHub/GitLab/Sentry and a job is created.' },
      { source: 'queued',       target: 'planning',     actor: 'daemon',  desc: 'A worker claims the job and initializes execution context.' },
      { source: 'planning',     target: 'implementing', actor: 'daemon',  desc: 'Plan is produced, then changes are drafted as a patch on the branch.' },
      { source: 'implementing', target: 'reviewing',    actor: 'daemon',  desc: 'Branch changes are ready for internal review/validation before CI.' },
      { source: 'reviewing',    target: 'implementing', actor: 'llm',     desc: 'Review found gaps; patch iteration resumes (git-edit loop).' },
      { source: 'reviewing',    target: 'testing',      actor: 'llm',     desc: 'Review passed and the branch proceeds to CI/test validation.' },
      { source: 'testing',      target: 'implementing', actor: 'daemon',  desc: 'CI/tests failed; patch loop returns for another edit pass.' },
      { source: 'testing',      target: 'rebasing',     actor: 'daemon',  desc: 'CI passed; branch is synchronized with base via rebase before PR handoff.' },
      { source: 'rebasing',     target: 'ready',        actor: 'daemon',  desc: 'Clean/fast-rebase. Branch remains clean and transitions to ready after readiness verification.' },
      { source: 'rebasing',     target: 'resolving_conflicts', actor: 'daemon',  desc: 'Rebase conflict region detected; enter LLM-assisted conflict recovery.' },
      { source: 'rebasing',     target: 'failed',       actor: 'daemon',  desc: 'Rebase could not be completed or conflict volume exceeds automated resolution policy.' },
      { source: 'resolving_conflicts', target: 'ready', actor: 'llm',  desc: 'Conflicts are resolved, files staged, rebase continued, and post-rebase tests pass.' },
      { source: 'resolving_conflicts', target: 'failed', actor: 'llm',  desc: 'Conflict resolution failed, markers remain, or recovery rebase cannot continue.' },
      { source: 'resolving_conflicts', target: 'failed', actor: 'daemon', desc: 'Post-rebase tests failed after conflicts were resolved.' },
      { source: 'queued',       target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" to stop this job before it started.' },
      { source: 'planning',     target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" while the LLM was planning.' },
      { source: 'implementing', target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" while the LLM was writing code.' },
      { source: 'reviewing',    target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" during code review.' },
      { source: 'testing',      target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" while tests were running.' },
      { source: 'rebasing',     target: 'ap_cancel',    actor: 'user',    desc: 'You ran "ap cancel" during rebase/readiness checks.' },
      { source: 'resolving_conflicts', target: 'ap_cancel', actor: 'user',    desc: 'You ran "ap cancel" while conflicts were being auto-resolved.' },
      { source: 'ap_cancel',    target: 'cancelled',    actor: 'user',    desc: 'Cancellation is applied and the job enters cancelled state.' },
      { source: 'ready',        target: 'approved',     actor: 'user',    desc: 'You ran "ap approve" â€” branch is rebased onto latest base and pushed. Clean rebase proceeds to PR creation. Conflicts block the transition and the job stays in ready (use ap retry to re-run pipeline).' },
      { source: 'ready',        target: 'approved',     actor: 'config',  match: 'auto_pr', desc: 'auto_pr is enabled â€” branch is rebased onto latest base and pushed. Clean rebase proceeds to PR creation. Conflicts block the transition and the job stays in ready.' },
      { source: 'ready',        target: 'rejected',     actor: 'user',    desc: 'You ran "ap reject" â€” the changes are discarded. Retryable.' },
      { source: 'planning',     target: 'step_error',   actor: 'daemon',  desc: 'The planning step hit an error (e.g. LLM crash, timeout).' },
      { source: 'implementing', target: 'step_error',   actor: 'daemon',  desc: 'Implementation hit an error (e.g. LLM crash, timeout).' },
      { source: 'reviewing',    target: 'step_error',   actor: 'daemon',  desc: 'Code review step hit an error (e.g. LLM crash, timeout).' },
      { source: 'testing',      target: 'step_error',   actor: 'daemon',  desc: 'Max implementâ†”review iterations reached. Needs human help.' },
      { source: 'step_error',   target: 'failed',       actor: 'daemon',  desc: 'Step error is applied and the job enters failed state.' },
      { source: 'failed',       target: 'ap_retry',     actor: 'user',    desc: 'You ran "ap retry" on a failed job.' },
      { source: 'rejected',     target: 'ap_retry',     actor: 'user',    desc: 'You ran "ap retry" on a rejected job.' },
      { source: 'cancelled',    target: 'ap_retry',     actor: 'user',    desc: 'You ran "ap retry" on a cancelled job.' },
      { source: 'ap_retry',     target: 'queued',       actor: 'user',    desc: 'Retry re-queues the job with optional guidance notes.' },
    ];

    const EDGE_META_BY_PAIR = new Map();
    EDGE_DEFS.forEach(def => {
      const pair = `${def.source}|${def.target}`;
      if (!EDGE_META_BY_PAIR.has(pair)) EDGE_META_BY_PAIR.set(pair, []);
      EDGE_META_BY_PAIR.get(pair).push(def);
    });

    edges.forEach(edge => {
      const source = edge.source;
      const target = edge.target;
      const pairKey = `${source}|${target}`;
      const candidates = EDGE_META_BY_PAIR.get(pairKey) || [];
      const labelLower = (edge.labelText || '').toLowerCase();
      const meta = candidates.find(def =>
        (def.match && labelLower.includes(def.match)) ||
        (!def.match && def.actor === edge.actorHint)
      ) || candidates[0] || null;
      const actor = meta?.actor || edge.actorHint || 'daemon';

      edgeConnections.push({
        source,
        target,
        actor,
        desc: meta?.desc || '',
        edgeId: edge.edgeId,
        labelText: edge.labelText || '',
        labelEl: edge.label || null,
        pathEl: edge.path || null,
      });
    });

    // Apply actor styling after connectivity/actor is resolved.
    edgeConnections.forEach(edge => {
      const color = ACTOR_COLORS[edge.actor] || '#8b949e';
      if (edge.labelEl) {
        edge.labelEl.setAttribute('data-actor', edge.actor);
        edge.labelEl.classList.add('edge-label-tagged');
        edge.labelEl.querySelectorAll('span, tspan, p, div').forEach(s => { s.style.color = color; });
      }
      if (edge.pathEl) {
        edge.pathEl.setAttribute('data-actor', edge.actor);
        edge.pathEl.style.stroke = color;
        if (isReentryEdge(edge)) edge.pathEl.classList.add('edge-reentry');
        const markerId = edge.pathEl.getAttribute('marker-end');
        if (markerId) {
          const id = markerId.replace(/url\(#?/, '').replace(/\)/, '').replace(/"/g, '');
          const marker = svg.querySelector('#' + CSS.escape(id));
          if (marker) {
            marker.querySelectorAll('path, polygon').forEach(p => {
              p.style.fill = color;
              p.style.stroke = color;
            });
          }
        }
      }
    });

    // â”€â”€ Collect node elements â”€â”€
    const nodeElements = {};
    const nodeLabels = {};
    const normalizeStateKey = (label = '') => (
      label
        .toLowerCase()
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/^[^a-z0-9]+/, '')
        .replace(/\s+/g, '_')
    );

    svg.querySelectorAll('.node').forEach(node => {
      const textEl = node.querySelector('.nodeLabel, text');
      if (!textEl) return;
      const label = textEl.textContent.trim();
      const key = normalizeStateKey(label);
      if (NODE_DESC[key]) {
        nodeElements[key] = node;
        nodeLabels[key] = label;
        node.setAttribute('data-state', key);
        if (key === 'ap_cancel' || key === 'ap_retry') {
          node.classList.add('human-command-node');
          node.querySelectorAll('rect, polygon, path').forEach(shape => {
            shape.style.stroke = ACTOR_COLORS.user;
            shape.style.fill = 'rgba(63,185,80,0.12)';
          });
          node.querySelectorAll('p, span, tspan, text').forEach(txt => {
            txt.style.color = ACTOR_COLORS.user;
          });
        }
      }
    });

    // â”€â”€ Legend interactions â”€â”€
    const legendItems = document.querySelectorAll('.legend-item');
    let edgeClickHandled = false;

    const clearHighlights = () => {
      container.classList.remove('filtering', 'node-filter');
      svg.querySelectorAll('.hl').forEach(el => el.classList.remove('hl'));
    };
    const clearLegendLocks = () => legendItems.forEach(li => li.classList.remove('locked', 'active'));
    const highlightEdgeSet = (edges, mode = 'node-filter') => {
      if (!edges.length) return;
      if (mode) container.classList.add(mode);
      const connectedNodes = new Set();
      edges.forEach(edge => {
        if (edge.labelEl) edge.labelEl.classList.add('hl');
        if (edge.pathEl) edge.pathEl.classList.add('hl');
        connectedNodes.add(edge.source);
        connectedNodes.add(edge.target);
      });
      for (const [name, el] of Object.entries(nodeElements)) {
        if (connectedNodes.has(name)) el.classList.add('hl');
      }
      svg.querySelectorAll('.cluster').forEach(cl => {
        if (cl.querySelector('.node.hl')) cl.classList.add('hl');
      });
    };

    legendItems.forEach(item => {
      const actor = item.dataset.actor;

      item.addEventListener('mouseenter', () => {
        clearHighlights();
        container.classList.add('filtering');
        highlightEdgeSet(edgeConnections.filter(e => e.actor === actor), null);
        item.classList.add('active');
      });

      item.addEventListener('mouseleave', () => {
        // If any legend item is locked, don't clear on mouseleave
        if (document.querySelector('.legend-item.locked')) return;
        clearHighlights();
        item.classList.remove('active');
      });

      // Click to lock
      item.addEventListener('click', () => {
        const isActive = item.classList.contains('locked');
        clearLegendLocks();
        clearHighlights();
        if (isActive) return; // toggle off

        item.classList.add('locked', 'active');
        highlightEdgeSet(edgeConnections.filter(e => e.actor === actor), 'filtering');
      });
    });

    // â”€â”€ Node click: highlight connected edges â”€â”€
    for (const [name, el] of Object.entries(nodeElements)) {
      el.addEventListener('click', (e) => {
        e.stopPropagation();

        // Clear legend locks
        clearLegendLocks();

        const wasActive = container.classList.contains('node-filter') &&
                          el.classList.contains('hl') &&
                          svg.querySelectorAll('.node.hl').length === 1;

        clearHighlights();

        if (wasActive) return; // toggle off

        container.classList.add('node-filter');
        el.classList.add('hl');

        // Find all edges connected to this node
        const connectedNodes = new Set([name]);
        edgeConnections.forEach(edge => {
          if (edge.source === name || edge.target === name) {
            if (edge.labelEl) edge.labelEl.classList.add('hl');
            if (edge.pathEl) edge.pathEl.classList.add('hl');
            connectedNodes.add(edge.source);
            connectedNodes.add(edge.target);
          }
        });

        // Highlight connected nodes
        for (const [n, nodeEl] of Object.entries(nodeElements)) {
          if (connectedNodes.has(n)) nodeEl.classList.add('hl');
        }

        // Highlight parent clusters
        svg.querySelectorAll('.cluster').forEach(cl => {
          if (cl.querySelector('.node.hl')) cl.classList.add('hl');
        });
      });
    }

    // â”€â”€ Click edge label to isolate that transition â”€â”€
    function handleEdgeClick(edge) {
      edgeClickHandled = true;

      clearLegendLocks();
      const wasActive = container.classList.contains('node-filter') &&
                        svg.querySelectorAll('.edge-path.hl').length === 1 &&
                        ((edge.pathEl && edge.pathEl.classList.contains('hl')) ||
                         (edge.labelEl && edge.labelEl.classList.contains('hl')));
      clearHighlights();

      if (wasActive) return;

      highlightEdgeSet([edge], 'node-filter');
    }

    edgeConnections.forEach(edge => {
      // Attach to the label group and ALL its descendants (spans, divs inside foreignObject)
      if (edge.labelEl) {
        const clickTargets = [edge.labelEl, ...edge.labelEl.querySelectorAll('*')];
        clickTargets.forEach(el => {
          el.style.cursor = 'pointer';
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            handleEdgeClick(edge);
          });
        });
      }

      // Also attach to the edge path
      if (edge.pathEl) {
        edge.pathEl.addEventListener('click', (e) => {
          e.stopPropagation();
          handleEdgeClick(edge);
        });
      }
    });

    // â”€â”€ Click background to reset â”€â”€
    container.addEventListener('click', (e) => {
      if (suppressBackgroundClick) { suppressBackgroundClick = false; return; }
      if (edgeClickHandled) { edgeClickHandled = false; return; }
      if (e.target.closest('.node')) return;
      clearHighlights();
      clearLegendLocks();
    });

    // â”€â”€ Tooltip on node hover â”€â”€
    const tooltip  = document.getElementById('tooltip');
    const ttState  = tooltip.querySelector('.tt-state');
    const ttDesc   = tooltip.querySelector('.tt-desc');

    for (const [name, el] of Object.entries(nodeElements)) {
      el.addEventListener('mouseenter', (e) => {
        ttState.textContent = nodeLabels[name] || name.replace(/_/g, ' ');
        ttDesc.textContent  = NODE_DESC[name] || '';
        tooltip.classList.add('visible');
      });

      el.addEventListener('mousemove', (e) => {
        tooltip.style.left = (e.clientX + 14) + 'px';
        tooltip.style.top  = (e.clientY + 14) + 'px';
      });

      el.addEventListener('mouseleave', () => {
        tooltip.classList.remove('visible');
      });
    }

    // â”€â”€ Tooltip on edge hover â”€â”€
    const ACTOR_LABELS = {
      daemon: 'Daemon (automatic)',
      user:   'User (CLI)',
      llm:    'LLM (AI decision)',
      config: 'Config (auto_pr)',
    };

    edgeConnections.forEach(edge => {
      const targets = [edge.labelEl, edge.pathEl].filter(Boolean);

      targets.forEach(el => {
        el.addEventListener('mouseenter', () => {
          const heading = `${edge.source} â†’ ${edge.target}`;
          const actorLabel = ACTOR_LABELS[edge.actor] || edge.actor;
          ttState.innerHTML = `${heading} <span style="color:${ACTOR_COLORS[edge.actor]};font-weight:400;font-size:0.72rem">${actorLabel}</span>`;
          ttDesc.textContent = edge.desc || '';
          tooltip.classList.add('visible');
        });

        el.addEventListener('mousemove', (e) => {
          tooltip.style.left = (e.clientX + 14) + 'px';
          tooltip.style.top  = (e.clientY + 14) + 'px';
        });

        el.addEventListener('mouseleave', () => {
          tooltip.classList.remove('visible');
        });
      });
    });
  </script>
</body>
</html>
